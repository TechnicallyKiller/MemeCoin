"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const beacon_utils_1 = require("@airgap/beacon-utils");
const beacon_types_1 = require("@airgap/beacon-types");
const __1 = require("../..");
const BeaconClient_1 = require("../beacon-client/BeaconClient");
const AccountManager_1 = require("../../managers/AccountManager");
const get_sender_id_1 = require("../../utils/get-sender-id");
const Logger_1 = require("../../utils/Logger");
const logger = new Logger_1.Logger('Client');
/**
 * @internalapi
 *
 * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.
 * For example, it selects and manages the transport and accounts.
 */
class Client extends BeaconClient_1.BeaconClient {
    get transport() {
        return this._transport.promise;
    }
    /**
     * Returns the connection status of the Client
     */
    get connectionStatus() {
        var _a, _b;
        return (_b = (_a = this._transport.promiseResult) === null || _a === void 0 ? void 0 : _a.connectionStatus) !== null && _b !== void 0 ? _b : beacon_types_1.TransportStatus.NOT_CONNECTED;
    }
    /**
     * Returns whether or not the transaport is ready
     */
    get ready() {
        return this.transport.then(() => undefined);
    }
    constructor(config) {
        var _a;
        super(config);
        /**
         * How many requests can be sent after another
         */
        this.rateLimit = 2;
        /**
         * The time window in seconds in which the "rateLimit" is checked
         */
        this.rateLimitWindowInSeconds = 5;
        /**
         * Stores the times when requests have been made to determine if the rate limit has been reached
         */
        this.requestCounter = [];
        this.transportListeners = new Map();
        this._transport = new beacon_utils_1.ExposedPromise();
        this.accountManager = new AccountManager_1.AccountManager(config.storage);
        this.matrixNodes = (_a = config.matrixNodes) !== null && _a !== void 0 ? _a : {};
        this.handleResponse = (message, connectionInfo) => {
            throw new Error(`not overwritten${JSON.stringify(message)} - ${JSON.stringify(connectionInfo)}`);
        };
    }
    cleanup() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.transportListeners.size) {
                return;
            }
            if (this._transport.isResolved()) {
                const transport = yield this.transport;
                yield Promise.all(Array.from(this.transportListeners.values()).map((listener) => transport.removeListener(listener)));
                this.transportListeners.clear();
            }
        });
    }
    /**
     * Return all locally known accounts
     */
    getAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.accountManager.getAccounts();
        });
    }
    /**
     * Return the account by ID
     * @param accountIdentifier The ID of an account
     */
    getAccount(accountIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.accountManager.getAccount(accountIdentifier);
        });
    }
    /**
     * Remove the account by ID
     * @param accountIdentifier The ID of an account
     */
    removeAccount(accountIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.accountManager.removeAccount(accountIdentifier);
        });
    }
    /**
     * Remove all locally stored accounts
     */
    removeAllAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.accountManager.removeAllAccounts();
        });
    }
    /**
     * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit
     */
    addRequestAndCheckIfRateLimited() {
        return __awaiter(this, void 0, void 0, function* () {
            const now = new Date().getTime();
            this.requestCounter = this.requestCounter.filter((date) => date + this.rateLimitWindowInSeconds * 1000 > now);
            this.requestCounter.push(now);
            return this.requestCounter.length > this.rateLimit;
        });
    }
    /**
     * This method initializes the client. It will check if the connection should be established to a
     * browser extension or if the P2P transport should be used.
     *
     * @param transport A transport that can be provided by the user
     */
    init(transport) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._transport.isResolved()) {
                return (yield this.transport).type;
            }
            yield this.setTransport(transport); // Let users define their own transport
            return transport.type;
        });
    }
    /**
     * Returns the metadata of this DApp
     */
    getOwnAppMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                senderId: yield (0, get_sender_id_1.getSenderId)(yield this.beaconId),
                name: this.name,
                icon: this.iconUrl
            };
        });
    }
    /**
     * Return all known peers
     */
    getPeers() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.transport).getPeers();
        });
    }
    /**
     * Add a new peer to the known peers
     * @param peer The new peer to add
     */
    addPeer(peer) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.transport).addPeer(peer);
        });
    }
    destroy() {
        const _super = Object.create(null, {
            destroy: { get: () => super.destroy }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (this._transport.isResolved()) {
                const transport = yield this.transport;
                yield this.cleanup();
                yield transport.disconnect();
                if (transport.type === beacon_types_1.TransportType.WALLETCONNECT) {
                    yield transport.doClientCleanup(); // any because I cannot import the type definition
                }
            }
            yield _super.destroy.call(this);
        });
    }
    /**
     * A "setter" for when the transport needs to be changed.
     */
    setTransport(transport) {
        return __awaiter(this, void 0, void 0, function* () {
            if (transport) {
                if (this._transport.isSettled()) {
                    // If the promise has already been resolved we need to create a new one.
                    this._transport = beacon_utils_1.ExposedPromise.resolve(transport);
                }
                else {
                    this._transport.resolve(transport);
                }
            }
            else {
                if (this._transport.isSettled()) {
                    // If the promise has already been resolved we need to create a new one.
                    this._transport = new beacon_utils_1.ExposedPromise();
                }
            }
        });
    }
    addListener(transport) {
        return __awaiter(this, void 0, void 0, function* () {
            // in beacon we subscribe to the transport on client init only
            // unsubscribing from the transport is only beneficial when running
            // a single page dApp.
            // However, while running a multiple tabs setup, if one of the dApps disconnects
            // the others wont't recover until after a page refresh
            if (this.transportListeners.has(transport.type)) {
                yield transport.removeListener(this.transportListeners.get(transport.type));
            }
            const subscription = (message, connectionInfo) => __awaiter(this, void 0, void 0, function* () {
                if (typeof message === 'string') {
                    const deserializedMessage = (yield new __1.Serializer().deserialize(message));
                    this.handleResponse(deserializedMessage, connectionInfo);
                }
            });
            this.transportListeners.set(transport.type, subscription);
            transport.addListener(subscription).catch((error) => logger.error('addListener', error));
        });
    }
    sendDisconnectToPeer(peer, transport) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = {
                id: yield (0, beacon_utils_1.generateGUID)(),
                version: peer.version,
                senderId: yield (0, get_sender_id_1.getSenderId)(yield this.beaconId),
                type: beacon_types_1.BeaconMessageType.Disconnect
            };
            const payload = yield new __1.Serializer().serialize(request);
            const selectedTransport = transport !== null && transport !== void 0 ? transport : (yield this.transport);
            yield selectedTransport.send(payload, peer);
        });
    }
}
exports.Client = Client;
//# sourceMappingURL=Client.js.map