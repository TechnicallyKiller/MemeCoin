import { ExposedPromise, generateGUID } from '@airgap/beacon-utils';
import { TransportType, TransportStatus, BeaconMessageType } from '@airgap/beacon-types';
import { Serializer } from '../..';
import { BeaconClient } from '../beacon-client/BeaconClient';
import { AccountManager } from '../../managers/AccountManager';
import { getSenderId } from '../../utils/get-sender-id';
import { Logger } from '../../utils/Logger';
const logger = new Logger('Client');
/**
 * @internalapi
 *
 * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.
 * For example, it selects and manages the transport and accounts.
 */
export class Client extends BeaconClient {
    accountManager;
    handleResponse;
    /**
     * How many requests can be sent after another
     */
    rateLimit = 2;
    /**
     * The time window in seconds in which the "rateLimit" is checked
     */
    rateLimitWindowInSeconds = 5;
    /**
     * Stores the times when requests have been made to determine if the rate limit has been reached
     */
    requestCounter = [];
    matrixNodes;
    transportListeners = new Map();
    _transport = new ExposedPromise();
    get transport() {
        return this._transport.promise;
    }
    /**
     * Returns the connection status of the Client
     */
    get connectionStatus() {
        return this._transport.promiseResult?.connectionStatus ?? TransportStatus.NOT_CONNECTED;
    }
    /**
     * Returns whether or not the transaport is ready
     */
    get ready() {
        return this.transport.then(() => undefined);
    }
    constructor(config) {
        super(config);
        this.accountManager = new AccountManager(config.storage);
        this.matrixNodes = config.matrixNodes ?? {};
        this.handleResponse = (message, connectionInfo) => {
            throw new Error(`not overwritten${JSON.stringify(message)} - ${JSON.stringify(connectionInfo)}`);
        };
    }
    async cleanup() {
        if (!this.transportListeners.size) {
            return;
        }
        if (this._transport.isResolved()) {
            const transport = await this.transport;
            await Promise.all(Array.from(this.transportListeners.values()).map((listener) => transport.removeListener(listener)));
            this.transportListeners.clear();
        }
    }
    /**
     * Return all locally known accounts
     */
    async getAccounts() {
        return this.accountManager.getAccounts();
    }
    /**
     * Return the account by ID
     * @param accountIdentifier The ID of an account
     */
    async getAccount(accountIdentifier) {
        return this.accountManager.getAccount(accountIdentifier);
    }
    /**
     * Remove the account by ID
     * @param accountIdentifier The ID of an account
     */
    async removeAccount(accountIdentifier) {
        return this.accountManager.removeAccount(accountIdentifier);
    }
    /**
     * Remove all locally stored accounts
     */
    async removeAllAccounts() {
        return this.accountManager.removeAllAccounts();
    }
    /**
     * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit
     */
    async addRequestAndCheckIfRateLimited() {
        const now = new Date().getTime();
        this.requestCounter = this.requestCounter.filter((date) => date + this.rateLimitWindowInSeconds * 1000 > now);
        this.requestCounter.push(now);
        return this.requestCounter.length > this.rateLimit;
    }
    /**
     * This method initializes the client. It will check if the connection should be established to a
     * browser extension or if the P2P transport should be used.
     *
     * @param transport A transport that can be provided by the user
     */
    async init(transport) {
        if (this._transport.isResolved()) {
            return (await this.transport).type;
        }
        await this.setTransport(transport); // Let users define their own transport
        return transport.type;
    }
    /**
     * Returns the metadata of this DApp
     */
    async getOwnAppMetadata() {
        return {
            senderId: await getSenderId(await this.beaconId),
            name: this.name,
            icon: this.iconUrl
        };
    }
    /**
     * Return all known peers
     */
    async getPeers() {
        return (await this.transport).getPeers();
    }
    /**
     * Add a new peer to the known peers
     * @param peer The new peer to add
     */
    async addPeer(peer) {
        return (await this.transport).addPeer(peer);
    }
    async destroy() {
        if (this._transport.isResolved()) {
            const transport = await this.transport;
            await this.cleanup();
            await transport.disconnect();
            if (transport.type === TransportType.WALLETCONNECT) {
                await transport.doClientCleanup(); // any because I cannot import the type definition
            }
        }
        await super.destroy();
    }
    /**
     * A "setter" for when the transport needs to be changed.
     */
    async setTransport(transport) {
        if (transport) {
            if (this._transport.isSettled()) {
                // If the promise has already been resolved we need to create a new one.
                this._transport = ExposedPromise.resolve(transport);
            }
            else {
                this._transport.resolve(transport);
            }
        }
        else {
            if (this._transport.isSettled()) {
                // If the promise has already been resolved we need to create a new one.
                this._transport = new ExposedPromise();
            }
        }
    }
    async addListener(transport) {
        // in beacon we subscribe to the transport on client init only
        // unsubscribing from the transport is only beneficial when running
        // a single page dApp.
        // However, while running a multiple tabs setup, if one of the dApps disconnects
        // the others wont't recover until after a page refresh
        if (this.transportListeners.has(transport.type)) {
            await transport.removeListener(this.transportListeners.get(transport.type));
        }
        const subscription = async (message, connectionInfo) => {
            if (typeof message === 'string') {
                const deserializedMessage = (await new Serializer().deserialize(message));
                this.handleResponse(deserializedMessage, connectionInfo);
            }
        };
        this.transportListeners.set(transport.type, subscription);
        transport.addListener(subscription).catch((error) => logger.error('addListener', error));
    }
    async sendDisconnectToPeer(peer, transport) {
        const request = {
            id: await generateGUID(),
            version: peer.version,
            senderId: await getSenderId(await this.beaconId),
            type: BeaconMessageType.Disconnect
        };
        const payload = await new Serializer().serialize(request);
        const selectedTransport = transport ?? (await this.transport);
        await selectedTransport.send(payload, peer);
    }
}
//# sourceMappingURL=Client.js.map